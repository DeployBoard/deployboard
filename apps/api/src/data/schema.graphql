type Query {
  serviceById(_id: MongoID!): Service
  serviceByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsServiceInput): [Service!]!
  serviceOne(
    """Filter by fields"""
    filter: FilterFindOneServiceInput
    skip: Int
    sort: SortFindOneServiceInput
  ): Service
  serviceMany(
    """Filter by fields"""
    filter: FilterFindManyServiceInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyServiceInput
  ): [Service!]!
  serviceCount(
    """Filter by fields"""
    filter: FilterCountServiceInput
  ): Int
  serviceConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyServiceInput

    """Sort argument for data ordering"""
    sort: SortConnectionServiceEnum = _ID_DESC
  ): ServiceConnection
  servicePagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyServiceInput
    sort: SortFindManyServiceInput
  ): ServicePagination
  logById(_id: MongoID!): Log
  logByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsLogInput): [Log!]!
  logOne(
    """Filter by fields"""
    filter: FilterFindOneLogInput
    skip: Int
    sort: SortFindOneLogInput
  ): Log
  logMany(
    """Filter by fields"""
    filter: FilterFindManyLogInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyLogInput
  ): [Log!]!
  logCount(
    """Filter by fields"""
    filter: FilterCountLogInput
  ): Int
  logConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyLogInput

    """Sort argument for data ordering"""
    sort: SortConnectionLogEnum = _ID_DESC
  ): LogConnection
  logPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyLogInput
    sort: SortFindManyLogInput
  ): LogPagination
  accountById(_id: MongoID!): Account
  accountByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsAccountInput): [Account!]!
  accountOne(
    """Filter by fields"""
    filter: FilterFindOneAccountInput
    skip: Int
    sort: SortFindOneAccountInput
  ): Account
  accountMany(
    """Filter by fields"""
    filter: FilterFindManyAccountInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyAccountInput
  ): [Account!]!
  accountCount(
    """Filter by fields"""
    filter: FilterCountAccountInput
  ): Int
  accountConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyAccountInput

    """Sort argument for data ordering"""
    sort: SortConnectionAccountEnum = _ID_DESC
  ): AccountConnection
  accountPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyAccountInput
    sort: SortFindManyAccountInput
  ): AccountPagination
  userById(_id: MongoID!): User
  userByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsUserInput): [User!]!
  userOne(
    """Filter by fields"""
    filter: FilterFindOneUserInput
    skip: Int
    sort: SortFindOneUserInput
  ): User
  userMany(
    """Filter by fields"""
    filter: FilterFindManyUserInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyUserInput
  ): [User!]!
  userCount(
    """Filter by fields"""
    filter: FilterCountUserInput
  ): Int
  userConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyUserInput

    """Sort argument for data ordering"""
    sort: SortConnectionUserEnum = _ID_DESC
  ): UserConnection
  userPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyUserInput
    sort: SortFindManyUserInput
  ): UserPagination
}

type Service {
  account: String!
  service: String!
  application: String!
  environments: [ServiceEnvironments]
  tags: [String]
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

type ServiceEnvironments {
  name: String
  status: String
  version: String
  timestamp: Date
  custom: JSON
  _id: MongoID
}

scalar Date

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""
The `ID` scalar type represents a unique MongoDB identifier in collection. MongoDB by default use 12-byte ObjectId value (https://docs.mongodb.com/manual/reference/bson-types/#objectid). But MongoDB also may accepts string or integer as correct values for _id field.
"""
scalar MongoID

enum SortFindByIdsServiceInput {
  _ID_ASC
  _ID_DESC
}

""""""
input FilterFindOneServiceInput {
  account: String
  service: String
  application: String
  environments: [FilterFindOneServiceEnvironmentsInput]
  tags: [String]
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneServiceOperatorsInput
  OR: [FilterFindOneServiceInput!]
  AND: [FilterFindOneServiceInput!]
}

""""""
input FilterFindOneServiceEnvironmentsInput {
  name: String
  status: String
  version: String
  timestamp: Date
  custom: JSON
  _id: MongoID
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneServiceOperatorsInput {
  _id: FilterFindOneService_idOperatorsInput
}

input FilterFindOneService_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortFindOneServiceInput {
  _ID_ASC
  _ID_DESC
}

""""""
input FilterFindManyServiceInput {
  account: String
  service: String
  application: String
  environments: [FilterFindManyServiceEnvironmentsInput]
  tags: [String]
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyServiceOperatorsInput
  OR: [FilterFindManyServiceInput!]
  AND: [FilterFindManyServiceInput!]
}

""""""
input FilterFindManyServiceEnvironmentsInput {
  name: String
  status: String
  version: String
  timestamp: Date
  custom: JSON
  _id: MongoID
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyServiceOperatorsInput {
  _id: FilterFindManyService_idOperatorsInput
}

input FilterFindManyService_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortFindManyServiceInput {
  _ID_ASC
  _ID_DESC
}

""""""
input FilterCountServiceInput {
  account: String
  service: String
  application: String
  environments: [FilterCountServiceEnvironmentsInput]
  tags: [String]
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountServiceOperatorsInput
  OR: [FilterCountServiceInput!]
  AND: [FilterCountServiceInput!]
}

""""""
input FilterCountServiceEnvironmentsInput {
  name: String
  status: String
  version: String
  timestamp: Date
  custom: JSON
  _id: MongoID
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountServiceOperatorsInput {
  _id: FilterCountService_idOperatorsInput
}

input FilterCountService_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

"""A connection to a list of items."""
type ServiceConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [ServiceEdge!]!
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""An edge in a connection."""
type ServiceEdge {
  """The item at the end of the edge"""
  node: Service!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionServiceEnum {
  _ID_DESC
  _ID_ASC
}

"""List of items with pagination."""
type ServicePagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Service!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

type PaginationInfo {
  currentPage: Int!
  perPage: Int!
  pageCount: Int
  itemCount: Int
  hasNextPage: Boolean
  hasPreviousPage: Boolean
}

type Log {
  account: String!
  service: String!
  application: String!
  environment: String!
  status: String!
  version: String!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

enum SortFindByIdsLogInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneLogInput {
  account: String
  service: String
  application: String
  environment: String
  status: String
  version: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneLogOperatorsInput
  OR: [FilterFindOneLogInput!]
  AND: [FilterFindOneLogInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneLogOperatorsInput {
  _id: FilterFindOneLog_idOperatorsInput
  createdAt: FilterFindOneLogCreatedAtOperatorsInput
}

input FilterFindOneLog_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneLogCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneLogInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyLogInput {
  account: String
  service: String
  application: String
  environment: String
  status: String
  version: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyLogOperatorsInput
  OR: [FilterFindManyLogInput!]
  AND: [FilterFindManyLogInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyLogOperatorsInput {
  _id: FilterFindManyLog_idOperatorsInput
  createdAt: FilterFindManyLogCreatedAtOperatorsInput
}

input FilterFindManyLog_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyLogCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyLogInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountLogInput {
  account: String
  service: String
  application: String
  environment: String
  status: String
  version: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountLogOperatorsInput
  OR: [FilterCountLogInput!]
  AND: [FilterCountLogInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountLogOperatorsInput {
  _id: FilterCountLog_idOperatorsInput
  createdAt: FilterCountLogCreatedAtOperatorsInput
}

input FilterCountLog_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountLogCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type LogConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [LogEdge!]!
}

"""An edge in a connection."""
type LogEdge {
  """The item at the end of the edge"""
  node: Log!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionLogEnum {
  _ID_DESC
  _ID_ASC
}

"""List of items with pagination."""
type LogPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Log!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

type Account {
  name: String!
  environments: [String]
  passwordPolicy: AccountPasswordPolicy!
  auth: String!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

type AccountPasswordPolicy {
  length: Float
  lowercase: Float
  uppercase: Float
  number: Float
  special: Float
  _id: MongoID
}

enum SortFindByIdsAccountInput {
  _ID_ASC
  _ID_DESC
}

""""""
input FilterFindOneAccountInput {
  name: String
  environments: [String]
  passwordPolicy: FilterFindOneAccountPasswordPolicyInput
  auth: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneAccountOperatorsInput
  OR: [FilterFindOneAccountInput!]
  AND: [FilterFindOneAccountInput!]
}

""""""
input FilterFindOneAccountPasswordPolicyInput {
  length: Float
  lowercase: Float
  uppercase: Float
  number: Float
  special: Float
  _id: MongoID
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneAccountOperatorsInput {
  _id: FilterFindOneAccount_idOperatorsInput
}

input FilterFindOneAccount_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortFindOneAccountInput {
  _ID_ASC
  _ID_DESC
}

""""""
input FilterFindManyAccountInput {
  name: String
  environments: [String]
  passwordPolicy: FilterFindManyAccountPasswordPolicyInput
  auth: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyAccountOperatorsInput
  OR: [FilterFindManyAccountInput!]
  AND: [FilterFindManyAccountInput!]
}

""""""
input FilterFindManyAccountPasswordPolicyInput {
  length: Float
  lowercase: Float
  uppercase: Float
  number: Float
  special: Float
  _id: MongoID
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyAccountOperatorsInput {
  _id: FilterFindManyAccount_idOperatorsInput
}

input FilterFindManyAccount_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortFindManyAccountInput {
  _ID_ASC
  _ID_DESC
}

""""""
input FilterCountAccountInput {
  name: String
  environments: [String]
  passwordPolicy: FilterCountAccountPasswordPolicyInput
  auth: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountAccountOperatorsInput
  OR: [FilterCountAccountInput!]
  AND: [FilterCountAccountInput!]
}

""""""
input FilterCountAccountPasswordPolicyInput {
  length: Float
  lowercase: Float
  uppercase: Float
  number: Float
  special: Float
  _id: MongoID
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountAccountOperatorsInput {
  _id: FilterCountAccount_idOperatorsInput
}

input FilterCountAccount_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

"""A connection to a list of items."""
type AccountConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [AccountEdge!]!
}

"""An edge in a connection."""
type AccountEdge {
  """The item at the end of the edge"""
  node: Account!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionAccountEnum {
  _ID_DESC
  _ID_ASC
}

"""List of items with pagination."""
type AccountPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Account!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

type User {
  email: String!
  account: String!
  enabled: Boolean!
  firstName: String!
  lastName: String!
  salt: String
  hashedPassword: String
  passwordExpires: Date
  role: String!
  sso: String
  sso_sub: String
  locale: String!
  zoneInfo: String!
  avatar: String
  lastLoggedIn: Date!
  theme: String!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

enum SortFindByIdsUserInput {
  _ID_ASC
  _ID_DESC
}

""""""
input FilterFindOneUserInput {
  email: String
  account: String
  enabled: Boolean
  firstName: String
  lastName: String
  salt: String
  hashedPassword: String
  passwordExpires: Date
  role: String
  sso: String
  sso_sub: String
  locale: String
  zoneInfo: String
  avatar: String
  lastLoggedIn: Date
  theme: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneUserOperatorsInput
  OR: [FilterFindOneUserInput!]
  AND: [FilterFindOneUserInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneUserOperatorsInput {
  _id: FilterFindOneUser_idOperatorsInput
}

input FilterFindOneUser_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortFindOneUserInput {
  _ID_ASC
  _ID_DESC
}

""""""
input FilterFindManyUserInput {
  email: String
  account: String
  enabled: Boolean
  firstName: String
  lastName: String
  salt: String
  hashedPassword: String
  passwordExpires: Date
  role: String
  sso: String
  sso_sub: String
  locale: String
  zoneInfo: String
  avatar: String
  lastLoggedIn: Date
  theme: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyUserOperatorsInput
  OR: [FilterFindManyUserInput!]
  AND: [FilterFindManyUserInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyUserOperatorsInput {
  _id: FilterFindManyUser_idOperatorsInput
}

input FilterFindManyUser_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortFindManyUserInput {
  _ID_ASC
  _ID_DESC
}

""""""
input FilterCountUserInput {
  email: String
  account: String
  enabled: Boolean
  firstName: String
  lastName: String
  salt: String
  hashedPassword: String
  passwordExpires: Date
  role: String
  sso: String
  sso_sub: String
  locale: String
  zoneInfo: String
  avatar: String
  lastLoggedIn: Date
  theme: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountUserOperatorsInput
  OR: [FilterCountUserInput!]
  AND: [FilterCountUserInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountUserOperatorsInput {
  _id: FilterCountUser_idOperatorsInput
}

input FilterCountUser_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

"""A connection to a list of items."""
type UserConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [UserEdge!]!
}

"""An edge in a connection."""
type UserEdge {
  """The item at the end of the edge"""
  node: User!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionUserEnum {
  _ID_DESC
  _ID_ASC
}

"""List of items with pagination."""
type UserPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [User!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

type Mutation {
  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  serviceCreateOne(record: CreateOneServiceInput!): CreateOneServicePayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  serviceCreateMany(records: [CreateManyServiceInput!]!): CreateManyServicePayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  serviceUpdateById(_id: MongoID!, record: UpdateByIdServiceInput!): UpdateByIdServicePayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  serviceUpdateOne(
    record: UpdateOneServiceInput!

    """Filter by fields"""
    filter: FilterUpdateOneServiceInput
    sort: SortUpdateOneServiceInput
    skip: Int
  ): UpdateOneServicePayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  serviceUpdateMany(
    record: UpdateManyServiceInput!

    """Filter by fields"""
    filter: FilterUpdateManyServiceInput
    sort: SortUpdateManyServiceInput
    skip: Int
    limit: Int = 100
  ): UpdateManyServicePayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  serviceRemoveById(_id: MongoID!): RemoveByIdServicePayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  serviceRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneServiceInput
    sort: SortRemoveOneServiceInput
  ): RemoveOneServicePayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  serviceRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyServiceInput!
    limit: Int = 100
  ): RemoveManyServicePayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  logCreateOne(record: CreateOneLogInput!): CreateOneLogPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  logCreateMany(records: [CreateManyLogInput!]!): CreateManyLogPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  logUpdateById(_id: MongoID!, record: UpdateByIdLogInput!): UpdateByIdLogPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  logUpdateOne(
    record: UpdateOneLogInput!

    """Filter by fields"""
    filter: FilterUpdateOneLogInput
    sort: SortUpdateOneLogInput
    skip: Int
  ): UpdateOneLogPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  logUpdateMany(
    record: UpdateManyLogInput!

    """Filter by fields"""
    filter: FilterUpdateManyLogInput
    sort: SortUpdateManyLogInput
    skip: Int
    limit: Int = 100
  ): UpdateManyLogPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  logRemoveById(_id: MongoID!): RemoveByIdLogPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  logRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneLogInput
    sort: SortRemoveOneLogInput
  ): RemoveOneLogPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  logRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyLogInput!
    limit: Int = 100
  ): RemoveManyLogPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  accountCreateOne(record: CreateOneAccountInput!): CreateOneAccountPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  accountCreateMany(records: [CreateManyAccountInput!]!): CreateManyAccountPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  accountUpdateById(_id: MongoID!, record: UpdateByIdAccountInput!): UpdateByIdAccountPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  accountUpdateOne(
    record: UpdateOneAccountInput!

    """Filter by fields"""
    filter: FilterUpdateOneAccountInput
    sort: SortUpdateOneAccountInput
    skip: Int
  ): UpdateOneAccountPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  accountUpdateMany(
    record: UpdateManyAccountInput!

    """Filter by fields"""
    filter: FilterUpdateManyAccountInput
    sort: SortUpdateManyAccountInput
    skip: Int
    limit: Int = 100
  ): UpdateManyAccountPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  accountRemoveById(_id: MongoID!): RemoveByIdAccountPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  accountRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneAccountInput
    sort: SortRemoveOneAccountInput
  ): RemoveOneAccountPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  accountRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyAccountInput!
    limit: Int = 100
  ): RemoveManyAccountPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  userCreateOne(record: CreateOneUserInput!): CreateOneUserPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  userCreateMany(records: [CreateManyUserInput!]!): CreateManyUserPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  userUpdateById(_id: MongoID!, record: UpdateByIdUserInput!): UpdateByIdUserPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  userUpdateOne(
    record: UpdateOneUserInput!

    """Filter by fields"""
    filter: FilterUpdateOneUserInput
    sort: SortUpdateOneUserInput
    skip: Int
  ): UpdateOneUserPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  userUpdateMany(
    record: UpdateManyUserInput!

    """Filter by fields"""
    filter: FilterUpdateManyUserInput
    sort: SortUpdateManyUserInput
    skip: Int
    limit: Int = 100
  ): UpdateManyUserPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  userRemoveById(_id: MongoID!): RemoveByIdUserPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  userRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneUserInput
    sort: SortRemoveOneUserInput
  ): RemoveOneUserPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  userRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyUserInput!
    limit: Int = 100
  ): RemoveManyUserPayload
}

type CreateOneServicePayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Service

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

interface ErrorInterface {
  """Generic error message"""
  message: String
}

""""""
input CreateOneServiceInput {
  account: String!
  service: String!
  application: String!
  environments: [ServiceEnvironmentsInput]
  tags: [String]
  updatedAt: Date
  createdAt: Date
}

input ServiceEnvironmentsInput {
  name: String
  status: String
  version: String
  timestamp: Date
  custom: JSON
  _id: MongoID
}

type CreateManyServicePayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Service!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyServiceInput {
  account: String!
  service: String!
  application: String!
  environments: [ServiceEnvironmentsInput]
  tags: [String]
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdServicePayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Service

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdServiceInput {
  account: String
  service: String
  application: String
  environments: [UpdateByIdServiceEnvironmentsInput]
  tags: [String]
  updatedAt: Date
  createdAt: Date
}

""""""
input UpdateByIdServiceEnvironmentsInput {
  name: String
  status: String
  version: String
  timestamp: Date
  custom: JSON
  _id: MongoID
}

type UpdateOneServicePayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Service

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneServiceInput {
  account: String
  service: String
  application: String
  environments: [UpdateOneServiceEnvironmentsInput]
  tags: [String]
  updatedAt: Date
  createdAt: Date
}

""""""
input UpdateOneServiceEnvironmentsInput {
  name: String
  status: String
  version: String
  timestamp: Date
  custom: JSON
  _id: MongoID
}

""""""
input FilterUpdateOneServiceInput {
  account: String
  service: String
  application: String
  environments: [FilterUpdateOneServiceEnvironmentsInput]
  tags: [String]
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneServiceOperatorsInput
  OR: [FilterUpdateOneServiceInput!]
  AND: [FilterUpdateOneServiceInput!]
}

""""""
input FilterUpdateOneServiceEnvironmentsInput {
  name: String
  status: String
  version: String
  timestamp: Date
  custom: JSON
  _id: MongoID
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneServiceOperatorsInput {
  _id: FilterUpdateOneService_idOperatorsInput
}

input FilterUpdateOneService_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortUpdateOneServiceInput {
  _ID_ASC
  _ID_DESC
}

type UpdateManyServicePayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyServiceInput {
  account: String
  service: String
  application: String
  environments: [UpdateManyServiceEnvironmentsInput]
  tags: [String]
  updatedAt: Date
  createdAt: Date
}

""""""
input UpdateManyServiceEnvironmentsInput {
  name: String
  status: String
  version: String
  timestamp: Date
  custom: JSON
  _id: MongoID
}

""""""
input FilterUpdateManyServiceInput {
  account: String
  service: String
  application: String
  environments: [FilterUpdateManyServiceEnvironmentsInput]
  tags: [String]
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyServiceOperatorsInput
  OR: [FilterUpdateManyServiceInput!]
  AND: [FilterUpdateManyServiceInput!]
}

""""""
input FilterUpdateManyServiceEnvironmentsInput {
  name: String
  status: String
  version: String
  timestamp: Date
  custom: JSON
  _id: MongoID
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyServiceOperatorsInput {
  _id: FilterUpdateManyService_idOperatorsInput
}

input FilterUpdateManyService_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortUpdateManyServiceInput {
  _ID_ASC
  _ID_DESC
}

type RemoveByIdServicePayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Service

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneServicePayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Service

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneServiceInput {
  account: String
  service: String
  application: String
  environments: [FilterRemoveOneServiceEnvironmentsInput]
  tags: [String]
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneServiceOperatorsInput
  OR: [FilterRemoveOneServiceInput!]
  AND: [FilterRemoveOneServiceInput!]
}

""""""
input FilterRemoveOneServiceEnvironmentsInput {
  name: String
  status: String
  version: String
  timestamp: Date
  custom: JSON
  _id: MongoID
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneServiceOperatorsInput {
  _id: FilterRemoveOneService_idOperatorsInput
}

input FilterRemoveOneService_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortRemoveOneServiceInput {
  _ID_ASC
  _ID_DESC
}

type RemoveManyServicePayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyServiceInput {
  account: String
  service: String
  application: String
  environments: [FilterRemoveManyServiceEnvironmentsInput]
  tags: [String]
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyServiceOperatorsInput
  OR: [FilterRemoveManyServiceInput!]
  AND: [FilterRemoveManyServiceInput!]
}

""""""
input FilterRemoveManyServiceEnvironmentsInput {
  name: String
  status: String
  version: String
  timestamp: Date
  custom: JSON
  _id: MongoID
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyServiceOperatorsInput {
  _id: FilterRemoveManyService_idOperatorsInput
}

input FilterRemoveManyService_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

type CreateOneLogPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Log

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneLogInput {
  account: String!
  service: String!
  application: String!
  environment: String!
  status: String!
  version: String!
  updatedAt: Date
  createdAt: Date
}

type CreateManyLogPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Log!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyLogInput {
  account: String!
  service: String!
  application: String!
  environment: String!
  status: String!
  version: String!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdLogPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Log

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdLogInput {
  account: String
  service: String
  application: String
  environment: String
  status: String
  version: String
  updatedAt: Date
  createdAt: Date
}

type UpdateOneLogPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Log

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneLogInput {
  account: String
  service: String
  application: String
  environment: String
  status: String
  version: String
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneLogInput {
  account: String
  service: String
  application: String
  environment: String
  status: String
  version: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneLogOperatorsInput
  OR: [FilterUpdateOneLogInput!]
  AND: [FilterUpdateOneLogInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneLogOperatorsInput {
  _id: FilterUpdateOneLog_idOperatorsInput
  createdAt: FilterUpdateOneLogCreatedAtOperatorsInput
}

input FilterUpdateOneLog_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneLogCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneLogInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyLogPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyLogInput {
  account: String
  service: String
  application: String
  environment: String
  status: String
  version: String
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyLogInput {
  account: String
  service: String
  application: String
  environment: String
  status: String
  version: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyLogOperatorsInput
  OR: [FilterUpdateManyLogInput!]
  AND: [FilterUpdateManyLogInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyLogOperatorsInput {
  _id: FilterUpdateManyLog_idOperatorsInput
  createdAt: FilterUpdateManyLogCreatedAtOperatorsInput
}

input FilterUpdateManyLog_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyLogCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyLogInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdLogPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Log

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneLogPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Log

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneLogInput {
  account: String
  service: String
  application: String
  environment: String
  status: String
  version: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneLogOperatorsInput
  OR: [FilterRemoveOneLogInput!]
  AND: [FilterRemoveOneLogInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneLogOperatorsInput {
  _id: FilterRemoveOneLog_idOperatorsInput
  createdAt: FilterRemoveOneLogCreatedAtOperatorsInput
}

input FilterRemoveOneLog_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneLogCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneLogInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyLogPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyLogInput {
  account: String
  service: String
  application: String
  environment: String
  status: String
  version: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyLogOperatorsInput
  OR: [FilterRemoveManyLogInput!]
  AND: [FilterRemoveManyLogInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyLogOperatorsInput {
  _id: FilterRemoveManyLog_idOperatorsInput
  createdAt: FilterRemoveManyLogCreatedAtOperatorsInput
}

input FilterRemoveManyLog_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyLogCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneAccountPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Account

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneAccountInput {
  name: String!
  environments: [String]
  passwordPolicy: AccountPasswordPolicyInput!
  auth: String!
  updatedAt: Date
  createdAt: Date
}

input AccountPasswordPolicyInput {
  length: Float
  lowercase: Float
  uppercase: Float
  number: Float
  special: Float
  _id: MongoID
}

type CreateManyAccountPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Account!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyAccountInput {
  name: String!
  environments: [String]
  passwordPolicy: AccountPasswordPolicyInput!
  auth: String!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdAccountPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Account

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdAccountInput {
  name: String
  environments: [String]
  passwordPolicy: UpdateByIdAccountPasswordPolicyInput
  auth: String
  updatedAt: Date
  createdAt: Date
}

""""""
input UpdateByIdAccountPasswordPolicyInput {
  length: Float
  lowercase: Float
  uppercase: Float
  number: Float
  special: Float
  _id: MongoID
}

type UpdateOneAccountPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Account

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneAccountInput {
  name: String
  environments: [String]
  passwordPolicy: UpdateOneAccountPasswordPolicyInput
  auth: String
  updatedAt: Date
  createdAt: Date
}

""""""
input UpdateOneAccountPasswordPolicyInput {
  length: Float
  lowercase: Float
  uppercase: Float
  number: Float
  special: Float
  _id: MongoID
}

""""""
input FilterUpdateOneAccountInput {
  name: String
  environments: [String]
  passwordPolicy: FilterUpdateOneAccountPasswordPolicyInput
  auth: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneAccountOperatorsInput
  OR: [FilterUpdateOneAccountInput!]
  AND: [FilterUpdateOneAccountInput!]
}

""""""
input FilterUpdateOneAccountPasswordPolicyInput {
  length: Float
  lowercase: Float
  uppercase: Float
  number: Float
  special: Float
  _id: MongoID
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneAccountOperatorsInput {
  _id: FilterUpdateOneAccount_idOperatorsInput
}

input FilterUpdateOneAccount_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortUpdateOneAccountInput {
  _ID_ASC
  _ID_DESC
}

type UpdateManyAccountPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyAccountInput {
  name: String
  environments: [String]
  passwordPolicy: UpdateManyAccountPasswordPolicyInput
  auth: String
  updatedAt: Date
  createdAt: Date
}

""""""
input UpdateManyAccountPasswordPolicyInput {
  length: Float
  lowercase: Float
  uppercase: Float
  number: Float
  special: Float
  _id: MongoID
}

""""""
input FilterUpdateManyAccountInput {
  name: String
  environments: [String]
  passwordPolicy: FilterUpdateManyAccountPasswordPolicyInput
  auth: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyAccountOperatorsInput
  OR: [FilterUpdateManyAccountInput!]
  AND: [FilterUpdateManyAccountInput!]
}

""""""
input FilterUpdateManyAccountPasswordPolicyInput {
  length: Float
  lowercase: Float
  uppercase: Float
  number: Float
  special: Float
  _id: MongoID
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyAccountOperatorsInput {
  _id: FilterUpdateManyAccount_idOperatorsInput
}

input FilterUpdateManyAccount_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortUpdateManyAccountInput {
  _ID_ASC
  _ID_DESC
}

type RemoveByIdAccountPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Account

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneAccountPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Account

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneAccountInput {
  name: String
  environments: [String]
  passwordPolicy: FilterRemoveOneAccountPasswordPolicyInput
  auth: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneAccountOperatorsInput
  OR: [FilterRemoveOneAccountInput!]
  AND: [FilterRemoveOneAccountInput!]
}

""""""
input FilterRemoveOneAccountPasswordPolicyInput {
  length: Float
  lowercase: Float
  uppercase: Float
  number: Float
  special: Float
  _id: MongoID
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneAccountOperatorsInput {
  _id: FilterRemoveOneAccount_idOperatorsInput
}

input FilterRemoveOneAccount_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortRemoveOneAccountInput {
  _ID_ASC
  _ID_DESC
}

type RemoveManyAccountPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyAccountInput {
  name: String
  environments: [String]
  passwordPolicy: FilterRemoveManyAccountPasswordPolicyInput
  auth: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyAccountOperatorsInput
  OR: [FilterRemoveManyAccountInput!]
  AND: [FilterRemoveManyAccountInput!]
}

""""""
input FilterRemoveManyAccountPasswordPolicyInput {
  length: Float
  lowercase: Float
  uppercase: Float
  number: Float
  special: Float
  _id: MongoID
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyAccountOperatorsInput {
  _id: FilterRemoveManyAccount_idOperatorsInput
}

input FilterRemoveManyAccount_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

type CreateOneUserPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: User

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneUserInput {
  email: String!
  account: String!
  enabled: Boolean!
  firstName: String!
  lastName: String!
  salt: String
  hashedPassword: String
  passwordExpires: Date
  role: String!
  sso: String
  sso_sub: String
  locale: String!
  zoneInfo: String!
  avatar: String
  lastLoggedIn: Date!
  theme: String!
  updatedAt: Date
  createdAt: Date
}

type CreateManyUserPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [User!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyUserInput {
  email: String!
  account: String!
  enabled: Boolean!
  firstName: String!
  lastName: String!
  salt: String
  hashedPassword: String
  passwordExpires: Date
  role: String!
  sso: String
  sso_sub: String
  locale: String!
  zoneInfo: String!
  avatar: String
  lastLoggedIn: Date!
  theme: String!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdUserPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: User

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdUserInput {
  email: String
  account: String
  enabled: Boolean
  firstName: String
  lastName: String
  salt: String
  hashedPassword: String
  passwordExpires: Date
  role: String
  sso: String
  sso_sub: String
  locale: String
  zoneInfo: String
  avatar: String
  lastLoggedIn: Date
  theme: String
  updatedAt: Date
  createdAt: Date
}

type UpdateOneUserPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: User

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneUserInput {
  email: String
  account: String
  enabled: Boolean
  firstName: String
  lastName: String
  salt: String
  hashedPassword: String
  passwordExpires: Date
  role: String
  sso: String
  sso_sub: String
  locale: String
  zoneInfo: String
  avatar: String
  lastLoggedIn: Date
  theme: String
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneUserInput {
  email: String
  account: String
  enabled: Boolean
  firstName: String
  lastName: String
  salt: String
  hashedPassword: String
  passwordExpires: Date
  role: String
  sso: String
  sso_sub: String
  locale: String
  zoneInfo: String
  avatar: String
  lastLoggedIn: Date
  theme: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneUserOperatorsInput
  OR: [FilterUpdateOneUserInput!]
  AND: [FilterUpdateOneUserInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneUserOperatorsInput {
  _id: FilterUpdateOneUser_idOperatorsInput
}

input FilterUpdateOneUser_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortUpdateOneUserInput {
  _ID_ASC
  _ID_DESC
}

type UpdateManyUserPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyUserInput {
  email: String
  account: String
  enabled: Boolean
  firstName: String
  lastName: String
  salt: String
  hashedPassword: String
  passwordExpires: Date
  role: String
  sso: String
  sso_sub: String
  locale: String
  zoneInfo: String
  avatar: String
  lastLoggedIn: Date
  theme: String
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyUserInput {
  email: String
  account: String
  enabled: Boolean
  firstName: String
  lastName: String
  salt: String
  hashedPassword: String
  passwordExpires: Date
  role: String
  sso: String
  sso_sub: String
  locale: String
  zoneInfo: String
  avatar: String
  lastLoggedIn: Date
  theme: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyUserOperatorsInput
  OR: [FilterUpdateManyUserInput!]
  AND: [FilterUpdateManyUserInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyUserOperatorsInput {
  _id: FilterUpdateManyUser_idOperatorsInput
}

input FilterUpdateManyUser_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortUpdateManyUserInput {
  _ID_ASC
  _ID_DESC
}

type RemoveByIdUserPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: User

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneUserPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: User

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneUserInput {
  email: String
  account: String
  enabled: Boolean
  firstName: String
  lastName: String
  salt: String
  hashedPassword: String
  passwordExpires: Date
  role: String
  sso: String
  sso_sub: String
  locale: String
  zoneInfo: String
  avatar: String
  lastLoggedIn: Date
  theme: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneUserOperatorsInput
  OR: [FilterRemoveOneUserInput!]
  AND: [FilterRemoveOneUserInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneUserOperatorsInput {
  _id: FilterRemoveOneUser_idOperatorsInput
}

input FilterRemoveOneUser_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortRemoveOneUserInput {
  _ID_ASC
  _ID_DESC
}

type RemoveManyUserPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyUserInput {
  email: String
  account: String
  enabled: Boolean
  firstName: String
  lastName: String
  salt: String
  hashedPassword: String
  passwordExpires: Date
  role: String
  sso: String
  sso_sub: String
  locale: String
  zoneInfo: String
  avatar: String
  lastLoggedIn: Date
  theme: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyUserOperatorsInput
  OR: [FilterRemoveManyUserInput!]
  AND: [FilterRemoveManyUserInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyUserOperatorsInput {
  _id: FilterRemoveManyUser_idOperatorsInput
}

input FilterRemoveManyUser_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}
